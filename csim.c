#include <stdio.h>
#include <stdlib.h>
#include <getopt.h>
#include <unistd.h>
#include <math.h>
#include "cachelab.h"

// Nils Backe nabacke
// Varnika Sinha vsinha2
// Team name: i_need_arrays

/* Remember all commenting rules apply!
   - Create header comments for functions
*/

/* Ideas/Outline:
   - Create a function reading the command line arguments (should also be in a
     struct), creating various types of caches (possibly create a function that
     prints out the usage if user enters it wrong)
   - Cache Structure
      - each line should be a struct
      - each set should be (a struct containing) array of structs
      - cache should be an array of arrays of structs (2D array of structs)
   - Other functions manipulating the cache
      - Build up cache (when first running program)
      - Searching for specific data (getting a hit/miss)
      - Flushing data (LRU) when full
   - Print out performance of cache at the end (use a struct to keep track)
*/

// Memory address var specifically to hold 64 bits
typedef unsigned long mem_addr_t;

// Structs
// Cache parameters
typedef struct {
  int s; // 2^s cache sets
  int b; // cacheline block size 2^b bytes
  int E; // number of cache lines per set
  int S; // number of sets (S = 2^s)
  int B; // cache line block size in bytes (B = 2^b)

  int hits; // number of hits generated by cache
  int misses; // number of misses generated by cache
  int evictions; // number of evictions done by cache
} cache_param;

// Line
typedef struct {
  int valid;
  mem_addr_t tag;
  int lastUsed;
} cache_line;

// Set
typedef struct {
  cache_line *lines;
} cache_set;

// Cache
typedef struct {
  cache_set *sets;
} cache;

void simulateCache(cache* c, cache_param* param, mem_addr_t address);
cache* buildCache(int numSets, int numLines, int blockSize);
int getNextEvictedLine(cache_set currentSet, cache_param* param);
mem_addr_t calculateSetIndex(cache_param* param, mem_addr_t address);
void freeCache(cache* c, int numSets, int numLines, int blockSize);
void printUsage(void);

/**
 * Main method of program
 * @param argc number of command line arguments
 * @param argv the string of command line arguments
 * @return 0 if successfully exited, 1 if not
 */
int main(int argc, char **argv) {
  cache* c;
  int s = 0;
  int b = 0;
  int E = 0;
  int S = 0; // 2 ^ s
  int B = 0; // 2 ^ b
  char* traceString;
  cache_param* param;
  FILE* traceFile;

  // allocate memory for cache_param
  param = (cache_param*) malloc(sizeof(cache_param));

  // Read in command line arguments
  char ch;
  while ((ch = getopt(argc, argv, "s:E:b:t:vh")) != -1) {
    if (ch == 'h') {
      printUsage();
      return 0;
    } else if (ch == 'v') {
      // verbose mode
    } else if (ch == 's') {
      s = atoi(optarg);
    } else if (ch == 'E') {
      E = atoi(optarg);
    } else if (ch == 'b') {
      b = atoi(optarg);
    } else if (ch == 't') {
      traceString = optarg;
    }
  }

  // Set cache parameters
  S = pow(2, s);
  B = pow(2, b);
  param->s = s;
  param->b = b;
  param->E = E;
  param->S = S;
  param->B = B;
  param->hits = 0;
  param->misses = 0;
  param->evictions = 0;

  // Allocate the cache
  c = buildCache(S, E);
  traceFile = fopen(traceString, "r"); // read file
  if (!traceFile) {
    printf("Could not open file.\n");
    return 1;
  }

  char operation = 0;
  mem_addr_t address = 0;
  int size = 0;

  // interpret file
  // "char unsigned long, int"
  while (fscanf(traceFile, " %c %lu,%d", &operation, &address, &size) == 3) {
    printf("%c %lu,%d ", operation, address, size);
    if (operation == 'L' || operation == 'S') {
      simulateCache(c, param, address);
    } else if (operation == 'M') { // a load and a store
      simulateCache(c, param, address);
      simulateCache(c, param, address);
    }
  }

  printSummary(param->hits, param->misses, param->evictions);
  fclose(traceFile);
  free(param);
  freeCache(c, S, E, B);
  return 0;
}

/**
 * Returns an allocated cache struct
 * @param numSets S, the number of sets in the cache
 * @param numLines E, the number of lines per cache
 * @return An allocated cache struct
 */
cache* buildCache(int numSets, int numLines) {
  // Allocate cache
  cache* c = (cache*) malloc(sizeof(cache));

  // Allocate cache sets
  c->sets = (cache_set*) malloc(sizeof(cache_set) * numSets);

  // for every set
  for (int i = 0; i < numSets; i++) {
    // Allocate cache lines
    c->sets[i].lines = (cache_line*) malloc(sizeof(cache_line) * numLines);

    // Allocate each line
    for (int j = 0; j < numLines; j++) {
      cache_line line;
      // set defaults
      line.valid = 0;
      line.tag = 0;
      line.lastUsed = 0;
      c->sets[i].lines[j] = line;
    }
  }
  return c;
}

/**
 * Simulates a cache retrieval
 * @param c A pointer to a cache struct
 * @param param A pointer to a cache_param struct
 * @param address The address to retrieve from the cache
 */
void simulateCache(cache* c, cache_param* param, mem_addr_t address) {
  // get the set from the set bits of the address
  mem_addr_t setIndex = calculateSetIndex(param, address);
  cache_set currentSet = c->sets[setIndex];

  mem_addr_t tag = address >> (param->s + param->b); // tag is address shifted by the
  // number of block bits and the number of set index bits

  int cacheIsFull = 1; // 0 or 1, 0 if not full, 1 if full
  int emptyIndex = 0; // the index of an empty cache line, used if cache miss

  int cacheHit = 0; // 0 or 1, 0 if miss, 1 if hit

  // loop through all the lines in the set
  for (int i = 0; i < param->E; i++) {
    cache_line line = currentSet.lines[i];
    if (line.valid && line.tag == tag) {
      // cache hit!
      cacheHit = 1;
      param->hits++;
      line.lastUsed++;
      printf("hit\n");
    } else if (!line.valid) {
      cacheIsFull = 0; // there is empty space in the cache
      emptyIndex = i;
      // saves the last empty line in the cache
    }
  }

  if (cacheHit) {
    // nothing else to do
    return;
  } else {
    param->misses++;
    printf("miss\n");
  }

  if (cacheIsFull) { // eviction required
    int evictIndex = getNextEvictedLine(currentSet, param);
    currentSet.lines[evictIndex].valid = 1;
    currentSet.lines[evictIndex].tag = tag;
    currentSet.lines[evictIndex].lastUsed = 0;
    param->evictions++;
    printf("eviction\n");
  } else { // fill in empty line
    currentSet.lines[emptyIndex].valid = 1;
    currentSet.lines[emptyIndex].tag = tag;
    currentSet.lines[emptyIndex].lastUsed = 0;
  }

  return;
}

/**
 * Finds the line in the given set that is next up for evictions
 * The line with the greatest lastUsed
 * @param currentSet The cache_set struct that is being considered
 * @param param A pointer to a cache_param struct
 * @return the index of the line that is next up for eviction
 */
int getNextEvictedLine(cache_set currentSet, cache_param* param) {
  int evictionIndex = 0;
  int maxLastUsed = 0;
  // simple find max value in array loop
  for (int i = 0; i < param->E; i++) {
    if (currentSet.lines[i].lastUsed >= maxLastUsed) {
      maxLastUsed = currentSet.lines[i].lastUsed;
      evictionIndex = i;
    }
  }
  return evictionIndex;
}

/**
 * Returns the set index from the given address
 * @param param A pointer to a cache_param struct
 * @param address The address that is being considered
 * @return The set index for the given address
 */
mem_addr_t calculateSetIndex(cache_param* param, mem_addr_t address) {
  int addressLength = sizeof(mem_addr_t) * 8; // * 8 to get number of bits (not bytes)
  int sizeOfTag = addressLength - param->s - param->b;
  mem_addr_t setIndex = (address << sizeOfTag) >> sizeOfTag; // get rid of tag bits
  printf("%lu", setIndex >> param->b);
  return setIndex >> param->b; // get rid of block bits
}

/**
 * Frees all of the allocated pointers to structs
 * @param c A pointer to a cache struct
 * @param numSets The number of sets in the cache
 * @param numLines The number of lines per set
 * @param blockSize The block size
 */
void freeCache(cache* c, int numSets, int numLines, int blockSize) {
  for (int i = 0; i < numSets; i++) {
    if (c->sets[i].lines != NULL) {
      free(c->sets[i].lines);
    }
  }
  if (c->sets != NULL) {
    free(c->sets);
  }
}

/**
 * Prints out usage information of command line arguments
 */
 void printUsage(void) {
   printf("Usage: ./csim-ref [-hv] -s <s> -E <E> -b <b> -t <tracefile>\n");
   printf("-h: Optional help flag that prints usage info\n");
   printf("-v: Optional verbose flag that displays trace info\n");
   printf("-s <s>: Number of index bits (number of sets is 2^s)\n");
   printf("-E <E>: Associativity (number of lines per set)\n");
   printf("-b <b>: Number of block bits (the block size is 2^b)\n");
   printf("-t <tracefile>: Name of valgrind trace to replay\n");
 }
