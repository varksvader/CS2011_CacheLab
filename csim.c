#include <stdio.h>
#include <stdlib.h>
#include <getopt.h>
#include <unistd.h>
#include <math.h>
#include "cachelab.h"

// Nils Backe nabacke
// Varnika Sinha vsinha2
// Team name: nabacke_vsinha2 (i_need_arrays)

/* Ideas/Outline:
   - Create a function reading the command line arguments (should also be in a
     struct), creating various types of caches (possibly create a function that
     prints out the usage if user enters it wrong)
   - Cache Structure
      - each line should be a struct
      - each set should be (a struct containing) array of structs
      - cache should be an array of arrays of structs (2D array of structs)
   - Other functions manipulating the cache
      - Build up cache (when first running program)
      - Searching for specific data (getting a hit/miss)
      - Flushing data (LRU) when full
   - Print out performance of cache at the end (use a struct to keep track)
*/

// Memory address var specifically to hold 64 bits
typedef unsigned long mem_addr_t;

// Structs
// Cache parameters
typedef struct {
  int s; // 2^s cache sets
  int b; // cacheline block size 2^b bytes
  int E; // number of cache lines per set
  int S; // number of sets (S = 2^s)
  int B; // cache line block size in bytes (B = 2^b)

  int hits; // number of hits generated by cache
  int misses; // number of misses generated by cache
  int evictions; // number of evictions done by cache
  int verbose; // 0 or 1, 1 if verbose mode
} cache_param;

// Line
typedef struct {
  int valid; // valid bit
  mem_addr_t tag;
  int lastUsed; // number representing when this line was last used
} cache_line;

// Set
typedef struct {
  cache_line *lines; // array of lines
} cache_set;

// Cache
typedef struct {
  cache_set *sets; // array of sets
} cache;

void simulateCache(cache* c, cache_param* param, mem_addr_t address);
cache* buildCache(int numSets, int numLines /*, int blockSize*/);
int getNextEvictedLine(cache_set currentSet, cache_param* param);
mem_addr_t calculateSetIndex(cache_param* param, mem_addr_t address);
void freeCache(cache* c, int numSets, int numLines, int blockSize);
void printUsage(void);

/**
 * Main method of program
 * @param argc number of command line arguments
 * @param argv the string of command line arguments
 * @return 0 if successfully exited, 1 if not
 */
int main(int argc, char **argv) {
  cache* c; // pointer to cache struct
  int s = 0; // number of set index bits
  int b = 0; // number of block size bits
  int E = 0; // number of lines per set
  int S = 0; // 2 ^ s
  int B = 0; // 2 ^ b
  int v = 0; // verbose mode
  char* traceString; // -t in command line arguments
  cache_param* param; // pointer to param struct
  FILE* traceFile; // pointer to input file

  // allocate memory for cache_param
  param = (cache_param*) malloc(sizeof(cache_param));

  // Read in command line arguments
  char ch;
  while ((ch = getopt(argc, argv, "s:E:b:t:vh")) != -1) {
    if (ch == 'h') {
      // help
      printUsage();
      return 1;
    } else if (ch == 'v') {
      // verbose mode
      v = 1;
    } else if (ch == 's') {
      // number of set index bits
      s = atoi(optarg);
    } else if (ch == 'E') {
      // number of lines per set
      E = atoi(optarg);
    } else if (ch == 'b') {
      // number of block size bits
      b = atoi(optarg);
    } else if (ch == 't') {
      // trace file name
      traceString = optarg;
    }
  }

  // Set cache parameters
  S = pow(2, s);
  B = pow(2, b);
  param->s = s;
  param->b = b;
  param->E = E;
  param->S = S;
  param->B = B;
  param->hits = 0;
  param->misses = 0;
  param->evictions = 0;
  param->verbose = v;

  // Allocate the cache
  c = buildCache(S, E);
  traceFile = fopen(traceString, "r"); // read file
  // check if file is null (unable to read file)
  if (!traceFile) {
    printf("Could not open file.\n");
    return 1;
  }

  char operation = 0; // I, L, or S - the instruction in the trace file
  mem_addr_t address = 0; // the addresses in the trace file
  int dataSize = 0; // not used

  // interpret file
  // "char unsigned long,int"
  // always 3 arguments per line in the trace file
  while (fscanf(traceFile, " %c %lx,%d", &operation, &address, &dataSize) == 3) {
    if (operation == 'I') { // nothing to do if I
      continue;
    }

    if (param->verbose) {
      printf("%c %lx,%d", operation, address, dataSize);
    }

    if (operation == 'L' || operation == 'S') {
      simulateCache(c, param, address);
    } else if (operation == 'M') { // a load and a store
      simulateCache(c, param, address);
      simulateCache(c, param, address);
    }

    // this is the last step because some things are printed in the simulateCache()
    if (param->verbose) {
      printf("\n");
    }
  }

  // conclude program
  printSummary(param->hits, param->misses, param->evictions);
  fclose(traceFile);
  free(param);
  freeCache(c, S, E, B);
  return 0;
}

/**
 * Returns an allocated cache struct
 * @param numSets S, the number of sets in the cache
 * @param numLines E, the number of lines per cache
 * @return An allocated cache struct
 */
cache* buildCache(int numSets, int numLines) {
  // Allocate cache
  cache* c = (cache*) malloc(sizeof(cache));

  // Allocate cache sets
  c->sets = (cache_set*) malloc(sizeof(cache_set) * numSets);

  // for every set
  for (int i = 0; i < numSets; i++) {
    // Allocate cache lines
    c->sets[i].lines = (cache_line*) malloc(sizeof(cache_line) * numLines);

    // Allocate each line
    for (int j = 0; j < numLines; j++) {
      cache_line line;
      // set defaults
      line.valid = 0;
      line.tag = 0;
      line.lastUsed = 0;
      c->sets[i].lines[j] = line;
    }
  }
  return c;
}

/**
 * Simulates a cache retrieval
 * @param c A pointer to a cache struct
 * @param param A pointer to a cache_param struct
 * @param address The address to retrieve from the cache
 */
void simulateCache(cache* c, cache_param* param, mem_addr_t address) {
  // get the set from the set bits of the address
  mem_addr_t indexOfSet = calculateSetIndex(param, address);
  cache_set currentSet = c->sets[indexOfSet];

  mem_addr_t addtag = address >> (param->s + param->b); // tag is address shifted by the
  // number of block bits and the number of set index bits

  int cacheIsFull = 1; // 0 or 1, 0 if not full, 1 if full
  int emptyIndex = -1; // the index of an empty cache line, used if cache miss

  int cacheHit = 0; // 0 or 1, 0 if miss, 1 if hit

  // loop through all the lines in the set
  for (int i = 0; i < param->E; i++) {
    cache_line line = currentSet.lines[i];
    // line will always be the line at index i
    if (line.valid && line.tag == addtag) {
      // cache hit!
      cacheHit = 1;
      param->hits++;
      line.lastUsed++;
      if (param->verbose) {
        printf(" hit");
      }
    } else if (!line.valid) { // if there is an unused line
      cacheIsFull = 0; // there is empty space in the cache
      emptyIndex = i;
      // saves the last empty line in the cache
    }
  }

  if (cacheHit) { // hit
    // nothing else to do
    return;
  } else { // miss
    param->misses++;
    if (param->verbose) {
      printf(" miss");
    }
  }

  if (cacheIsFull) { // eviction required
    int evictIndex = getNextEvictedLine(currentSet, param);
    // get the index of the line to evict using LRU rules
    currentSet.lines[evictIndex].valid = 1;
    currentSet.lines[evictIndex].tag = addtag;
    currentSet.lines[evictIndex].lastUsed = 0;
    param->evictions++;
    if (param->verbose) {
      printf(" eviction");
    }
  } else { // fill in empty line
    currentSet.lines[emptyIndex].valid = 1;
    currentSet.lines[emptyIndex].tag = addtag;
    currentSet.lines[emptyIndex].lastUsed = 0;
  }
}

/**
 * Finds the line in the given set that is next up for evictions
 * The line with the greatest lastUsed
 * @param currentSet The cache_set struct that is being considered
 * @param param A pointer to a cache_param struct
 * @return the index of the line that is next up for eviction
 */
int getNextEvictedLine(cache_set currentSet, cache_param* param) {
  int evictionIndex = 0; // index of line to be evicted
  int maxLastUsed = 0; // needed to find max in array
  // simple find max value in array loop
  for (int i = 0; i < param->E; i++) {
    if (currentSet.lines[i].lastUsed >= maxLastUsed) {
      maxLastUsed = currentSet.lines[i].lastUsed;
      evictionIndex = i;
    }
  }
  return evictionIndex;
}

/**
 * Returns the set index from the given address
 * @param param A pointer to a cache_param struct
 * @param address The address that is being considered
 * @return The set index for the given address
 */
mem_addr_t calculateSetIndex(cache_param* param, mem_addr_t address) {
  int addressLength = sizeof(mem_addr_t) * 8; // * 8 to get number of bits (not bytes)
  int sizeOfTag = addressLength - param->s - param->b; // get number of bits of the tag
  mem_addr_t indexOfSet = (address << sizeOfTag) >> sizeOfTag; // get rid of tag bits
  return indexOfSet >> param->b; // get rid of block bits
}

/**
 * Frees all of the allocated pointers to structs
 * @param c A pointer to a cache struct
 * @param numSets The number of sets in the cache
 * @param numLines The number of lines per set
 * @param blockSize The block size
 */
void freeCache(cache* c, int numSets, int numLines, int blockSize) {
  for (int i = 0; i < numSets; i++) {
    // free each set's lines
    if (c->sets[i].lines != NULL) {
      free(c->sets[i].lines);
    }
  }
  // free the sets
  if (c->sets != NULL) {
    free(c->sets);
  }
}

/**
 * Prints out usage information of command line arguments
 */
 void printUsage(void) {
   printf("Usage: ./csim-ref [-hv] -s <s> -E <E> -b <b> -t <tracefile>\n");
   printf("-h: Optional help flag that prints usage info\n");
   printf("-v: Optional verbose flag that displays trace info\n");
   printf("-s <s>: Number of index bits (number of sets is 2^s)\n");
   printf("-E <E>: Associativity (number of lines per set)\n");
   printf("-b <b>: Number of block bits (the block size is 2^b)\n");
   printf("-t <tracefile>: Name of valgrind trace to replay\n");
 }
